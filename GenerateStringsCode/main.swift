#!/usr/bin/env swift

import Foundation

// MARK: Model

struct Entry {
    struct Argument {
        let name: String
        let type: String
    }

    let key: String
    let arguments: [Argument]
    let argumentsNamedExplicitly: Bool

    var joinedArgumentNames: String {
        return arguments.map({$0.name}).joinWithSeparator(", ")
    }

    var joinedArgumentDeclarations: String {
        let argumentDeclarations = arguments.enumerate().map({ return argumentDeclaration($0.1, isFirst: $0.0 == 0) })
        return argumentDeclarations.joinWithSeparator(", ")
    }

    init?(line: String) {
        let components = line.componentsSeparatedByString("\"")
        guard components.count == 5 else { return nil }

        key = components[1]
        let value = components[3]
        let comment: String? = components[4].containsString("//") ? components[4].componentsSeparatedByString("//").last! : nil

        let regex = try! NSRegularExpression(pattern: "%(ld|@)", options: [])

        let matches = regex.matchesInString(value, options: [], range: NSRange(location: 0, length: value.utf16.count))
        let formatSpecifiers = matches.flatMap(Entry.stringForTextCheckingResult(value))
        let argTypes = formatSpecifiers.flatMap(Entry.typeForFormatSpecifier)
        let argNames: [String]

        if let comment = comment, names = Entry.argNamesFromComment(comment) {
            argNames = names
            argumentsNamedExplicitly = true
        } else {
            argNames = argTypes.enumerate().map({ "arg\($0.0 + 1)" })
            argumentsNamedExplicitly = false
        }

        arguments = zip(argNames, argTypes).map(Argument.init)
    }

    private static func typeForFormatSpecifier(formatSpecifier: String) -> String? {
        return [
            "%@": "String",
            "%ld": "Int"
            ][formatSpecifier]
    }

    private static func stringForTextCheckingResult(text: String)(result: NSTextCheckingResult) -> String? {
        guard result.range.location != NSNotFound else { return nil }
        return (text as NSString).substringWithRange(result.range)
    }

    private static func argNamesFromComment(comment: String) -> [String]? {
        let names = comment
            .componentsSeparatedByString(",")
            .map({ $0.stringByTrimmingCharactersInSet(.whitespaceCharacterSet()) })
            .filter({ !$0.isEmpty })

        return names.count > 0 ? names : nil
    }

    private func argumentDeclaration(argument: Argument, isFirst: Bool) -> String {
        let name: String

        switch (argumentsNamedExplicitly, isFirst) {
        case (true, true):
            name = argument.name+" "+argument.name // Explicitly-named arguments have external labels
        case (false, false):
            name = "_ "+argument.name // Implicitly-named arguments have no external labels
        default:
            name = argument.name
        }

        return name+": "+argument.type
    }
}

// MARK: Utility

@noreturn func exitWithError(error: String) {
    print(error)
    exit(1)
}

func linesInFile(path: String) throws -> [String] {
    let contents = try String(contentsOfFile: path)
    return contents.componentsSeparatedByCharactersInSet(.newlineCharacterSet())
}

// MARK: Main

guard Process.arguments.count == 2 else {
    exitWithError("Usage: generate_strings_code.swift [input_strings_file]")
}

let inputPath = Process.arguments.last!
guard let inputContents = try? linesInFile(inputPath) else {
    exitWithError("Unable to load input file: \(inputPath)")
}

print("// NOTE: This file is automatically generated and should not be edited by hand")
print("import Foundation\n")
print("struct Strings {")

for entry in inputContents.flatMap(Entry.init) {
    let localized = "NSLocalizedString(\"\(entry.key)\", comment: \"\")"

    let content: String
    if entry.arguments.isEmpty {
        content = "var \(entry.key): String { return \(localized) }"
    } else {
        content = "func \(entry.key)(\(entry.joinedArgumentDeclarations)) -> String { return String.localizedStringWithFormat(\(localized), \(entry.joinedArgumentNames)) }"
    }

    print("    static \(content)")
}

print("}")
